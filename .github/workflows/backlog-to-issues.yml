name: Backlog â†’ Issues

on:
  # Manual run from the Actions tab
  workflow_dispatch:

permissions:
  contents: read    # to read docs/backlog.md from main
  issues: write     # to create issues
  metadata: read

jobs:
  create:
    name: create
    runs-on: ubuntu-latest
    # ðŸš¦ Only run when the workflow is on the main branch (skip PR branches)
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Parse backlog and create issues
        uses: actions/github-script@v7
        env:
          BACKLOG_PATH: docs/backlog.md
          BACKLOG_LABEL: backlog
        with:
          script: |
            const path = process.env.BACKLOG_PATH || 'docs/backlog.md';
            const labelName = process.env.BACKLOG_LABEL || 'backlog';
            const { owner, repo } = context.repo;

            function codes(s) {
              return [...s].map(c => c.charCodeAt(0)).join(' ');
            }

            async function getFileContent({ owner, repo, path, ref = 'main' }) {
              try {
                const res = await github.rest.repos.getContent({ owner, repo, path, ref });
                if (Array.isArray(res.data)) {
                  throw new Error(`${path} is a directory, expected a file`);
                }
                const enc = res.data.encoding || 'base64';
                const buf = Buffer.from(res.data.content, enc);
                return buf.toString('utf8');
              } catch (e) {
                core.error(`Unable to read ${path}@${ref}: ${e.message}`);
                throw e;
              }
            }

            async function ensureLabel({ owner, repo, name }) {
              try {
                const labels = await github.paginate(
                  github.rest.issues.listLabelsForRepo,
                  { owner, repo, per_page: 100 }
                );
                if (labels.some(l => l.name.toLowerCase() === name.toLowerCase())) {
                  core.info(`Label '${name}' exists`);
                  return;
                }
                await github.rest.issues.createLabel({
                  owner, repo,
                  name,
                  color: '0e8a16',
                  description: 'Created by Backlog â†’ Issues workflow'
                });
                core.info(`Created label '${name}'`);
              } catch (e) {
                core.warning(`ensureLabel warning: ${e.message}`);
              }
            }

            const content = await getFileContent({ owner, repo, path, ref: 'main' });

            const linesPreview = content.split('\n').slice(0, 20);
            core.info('----- BACKLOG PREVIEW (first 20 lines) -----');
            linesPreview.forEach((l, i) => {
              core.info(`${String(i+1).padStart(2,'0')}: ${l}`);
              core.info(`      [codes] ${codes(l)}`);
            });
            core.info('--------------------------------------------');

            const re = /^[ \t]*[-*][ \t]+\[[ xX]?\][ \t]+(.+?)\s*$/gm;
            const matches = [];
            for (const m of content.matchAll(re)) {
              const title = (m[1] || '').trim();
              if (title) matches.push(title);
            }
            core.info(`DEBUG: matches found: ${matches.length}`);

            if (matches.length === 0) {
              core.info('HINT: Each backlog line must look exactly like:');
              core.info('- [ ] My feature title');
              core.setFailed('No checklist items matched. See preview above for character codes (look for non-standard dashes or spaces).');
              return;
            }

            await ensureLabel({ owner, repo, name: labelName });

            const openIssues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'open', per_page: 100 }
            );
            const existing = new Set(openIssues.map(i => (i.title || '').trim()));

            let created = 0;
            for (const title of matches) {
              if (existing.has(title)) {
                core.info(`Skip existing: ${title}`);
                continue;
              }
              try {
                const issue = await github.rest.issues.create({
                  owner, repo, title,
                  labels: [labelName],
                });
                created++;
                core.info(`Created #${issue.data.number}: ${title}`);
              } catch (e) {
                core.warning(`Failed to create issue '${title}': ${e.message}`);
              }
            }

            core.info(`Done. Created ${created} issue(s).`);
