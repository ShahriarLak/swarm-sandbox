name: Backlog → Issues

on:
  workflow_dispatch:
    inputs:
      path:
        description: 'Backlog markdown path'
        required: true
        default: 'docs/backlog_pulsepilot_mvp_v1.md'

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  create:
    runs-on: ubuntu-latest
    steps:
      - name: Parse backlog and create issues
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const path = core.getInput('path') || 'docs/backlog_pulsepilot_mvp_v1.md';

            // fetch backlog file from main
            const res = await github.rest.repos.getContent({ owner, repo, path, ref: 'main' });
            const content = Buffer.from(res.data.content, 'base64').toString('utf8');
            const lines = content.split('\n');

            function labelsFrom(line) {
              // grabs backticked labels at end: `feature` `p0` `frontend`
              const out = [];
              const re = /`([^`]+)`/g;
              let m;
              while ((m = re.exec(line)) !== null) out.push(m[1]);
              return out;
            }

            let currentEpic = null;
            const features = [];

            for (let i = 0; i < lines.length; i++) {
              const l = lines[i].trim();

              // Track current Epic title (from "## Epic …")
              if (/^##\s+Epic/i.test(l)) {
                currentEpic = l.replace(/^##\s+/, '').replace(/\s+`.*$/, '').trim(); // strip backtick labels
                continue;
              }

              // Feature blocks start with "### "
              if (/^###\s+/.test(l)) {
                const titleRaw = l.replace(/^###\s+/, '').trim();
                const title = titleRaw.replace(/\s+`.*$/, '').trim(); // remove trailing backtick labels
                const labels = labelsFrom(l);

                // Gather body until next heading
                let bodyLines = [];
                for (let j = i + 1; j < lines.length; j++) {
                  const tl = lines[j];
                  if (/^###\s+/.test(tl) || /^##\s+/.test(tl)) { i = j - 1; break; }
                  bodyLines.push(tl);
                  if (j === lines.length - 1) i = j;
                }

                let body = bodyLines.join('\n').trim();
                if (currentEpic) body = `**Parent Epic:** ${currentEpic}\n\n` + body;

                features.push({ title, labels, body });
              }
            }

            core.info(`Found ${features.length} feature items to create.`);

            // Avoid duplicates: skip if an open issue already has this exact title
            async function exists(title) {
              const q = `repo:${owner}/${repo} is:issue in:title "${title.replace(/"/g,'\\"')}"`;
              const sr = await github.rest.search.issuesAndPullRequests({ q });
              return sr.data.items.some(it => it.title === title && it.state !== 'closed');
            }

            const created = [];
            for (const f of features) {
              if (f.title.length < 3) continue; // ignore accidental blanks
              if (await exists(f.title)) {
                core.info(`Skip existing: ${f.title}`);
                continue;
              }
              const createdIssue = await github.rest.issues.create({
                owner, repo,
                title: f.title,
                body: f.body || '',
                labels: (f.labels || []).slice(0, 10)
              });
              created.push(createdIssue.data.html_url);
            }

            core.summary.addHeading('Backlog → Issues');
            core.summary.addRaw(`Created ${created.length} issues`).addBreak();
            for (const url of created) core.summary.addLink(url, url).addBreak();
            await core.summary.write();

            core.setOutput('created', JSON.stringify(created));
