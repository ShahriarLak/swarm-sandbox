name: Sync Project Priority

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened]

permissions:
  contents: read
  issues: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Sync Priority field from labels
        uses: actions/github-script@v7
        env:
          PROJECTS_TOKEN: ${{ secrets.PROJECTS_TOKEN }}
          PROJECT_NUMBER: 2        # from your URL .../projects/2/...
          FIELD_NAME: Priority
        with:
          script: |
            const token = process.env.PROJECTS_TOKEN;
            const projectNumber = Number(process.env.PROJECT_NUMBER);
            const fieldName = process.env.FIELD_NAME;

            const issue = context.payload.issue;
            const labels = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name).toLowerCase());

            function desiredFromLabels(arr) {
              if (arr.includes('priority: high')) return 'High';
              if (arr.includes('priority: medium')) return 'Medium';
              if (arr.includes('priority: low')) return 'Low';
              return null;
            }

            const desired = desiredFromLabels(labels);
            if (!desired) {
              core.info('No priority:* label on this issue; nothing to sync.');
              return;
            }

            async function gql(query, variables) {
              const resp = await github.request('POST /graphql', {
                headers: { authorization: 'bearer ' + token },
                query,
                variables
              });
              if (resp.data && resp.data.errors && resp.data.errors.length) {
                throw new Error('GraphQL: ' + resp.data.errors.map(e => e.message).join('; '));
              }
              return resp.data;
            }

            // --- DEBUG: who is this token and what projects can it see? ---
            const qWho = [
              'query{',
              '  viewer{',
              '    login',
              '    projectsV2(first:20){ nodes{ number title } }',
              '  }',
              '}'
            ].join('\n');
            const dWho = await gql(qWho, {});
            core.info('Token viewer.login = ' + dWho.data.viewer.login);
            core.info('Viewer projects: ' + JSON.stringify(dWho.data.viewer.projectsV2.nodes));

            // 1) Get project + Priority field + options (by viewer + number)
            const q1 = [
              'query($number:Int!){',
              '  viewer {',
              '    projectV2(number:$number){',
              '      id',
              '      title',
              '      fields(first:50){',
              '        nodes{',
              '          ... on ProjectV2SingleSelectField { id name options{ id name } }',
              '          ... on ProjectV2Field { id name }',
              '        }',
              '      }',
              '    }',
              '  }',
              '}'
            ].join('\n');

            const d1 = await gql(q1, { number: projectNumber });
            const project = d1.data?.viewer?.projectV2 || null;
            if (!project) {
              core.setFailed('viewer.projectV2 #' + projectNumber + ' not found. Likely cause: token belongs to a different GitHub user than the owner of this private project. Create the classic PAT on the SAME account that owns the project, then update the PROJECTS_TOKEN secret.');
              return;
            }

            const fields = project.fields?.nodes || [];
            const priorityField = fields.find(f => f && f.name === fieldName && f.options);
            if (!priorityField) { core.setFailed('Field "' + fieldName + '" not found'); return; }

            const option = priorityField.options.find(o => o && o.name && o.name.toLowerCase() === desired.toLowerCase());
            if (!option) { core.setFailed('Option "' + desired + '" not found'); return; }

            // 2) Find this issue's Project item (page items)
            const issueNodeId = issue.node_id;
            let itemId = null;
            let after = null;
            for (let i = 0; i < 30; i++) {
              const q2 = [
                'query($pid:ID!, $after:String){',
                '  node(id:$pid){',
                '    ... on ProjectV2 {',
                '      items(first:50, after:$after){',
                '        nodes{',
                '          id',
                '          content{ __typename ... on Issue { id number } }',
                '        }',
                '        pageInfo{ hasNextPage endCursor }',
                '      }',
                '    }',
                '  }',
                '}'
              ].join('\n');

              const d2 = await gql(q2, { pid: project.id, after: after });
              const node = d2.data ? d2.data.node : null;
              const items = node && node.items ? node.items.nodes || [] : [];
              for (const n of items) {
                if (n && n.content && n.content.__typename === 'Issue' && n.content.id === issueNodeId) {
                  itemId = n.id;
                  break;
                }
              }
              if (itemId) break;
              const pi = node && node.items ? node.items.pageInfo : null;
              if (!pi || !pi.hasNextPage) break;
              after = pi.endCursor;
            }
            if (!itemId) { core.setFailed('Issue #' + issue.number + ' is not in this project (check Auto-add)'); return; }

            // 3) Update field
            const m1 = [
              'mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!){',
              '  updateProjectV2ItemFieldValue(input:{',
              '    projectId:$projectId,',
              '    itemId:$itemId,',
              '    fieldId:$fieldId,',
              '    value:{ singleSelectOptionId:$optionId }',
              '  }){ projectV2Item { id } }',
              '}'
            ].join('\n');

            await gql(m1, { projectId: project.id, itemId: itemId, fieldId: priorityField.id, optionId: option.id });

            core.info('Priority set to ' + desired + ' for issue #' + issue.number);
